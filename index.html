# HPOS — Human Potential Operating System
# Python Core Engine (CLI / Logic Layer)
# Author: Sai + Ammu
# Philosophy-first, execution-driven system

import json
import datetime
import sys

# -------------------------------
# AI PERSONALITY ENGINE
# -------------------------------

class AIPersonality:
    OBSERVER = [
        "I’m noticing patterns. No need to rush.",
        "Your answers are forming a shape.",
        "Nothing here is random."
    ]

    REFLECTOR = [
        "There’s a consistency in how you respond.",
        "This tendency appears more than once.",
        "I see a direction forming."
    ]

    GUIDE = [
        "Awareness changes leverage.",
        "We’ll move one step at a time.",
        "Execution matters more than clarity."
    ]

    @staticmethod
    def speak(stage="observer"):
        import random
        if stage == "observer":
            return random.choice(AIPersonality.OBSERVER)
        if stage == "reflector":
            return random.choice(AIPersonality.REFLECTOR)
        if stage == "guide":
            return random.choice(AIPersonality.GUIDE)
        return ""


# -------------------------------
# COGNITIVE MODEL ENGINE
# -------------------------------

class CognitiveModel:
    def __init__(self):
        self.depth = 0
        self.action = 0
        self.emotion = 0
        self.structure = 0
        self.avoidance = 0

    def apply_effect(self, effect: dict):
        for k, v in effect.items():
            setattr(self, k, getattr(self, k) + v)

    def mirror_insights(self):
        insights = []
        if self.depth > self.action:
            insights.append("You prefer understanding before acting.")
        if self.action > self.depth:
            insights.append("You prefer movement over certainty.")
        if self.avoidance > 1:
            insights.append("You delay action when clarity feels incomplete.")
        if self.structure > 1:
            insights.append("You rely on structure to feel stable.")
        if self.emotion > 1:
            insights.append("Emotions influence your decisions.")
        return insights

    def as_dict(self):
        return {
            "depth": self.depth,
            "action": self.action,
            "emotion": self.emotion,
            "structure": self.structure,
            "avoidance": self.avoidance
        }


# -------------------------------
# QUESTION ENGINE
# -------------------------------

class QuestionEngine:
    def __init__(self):
        self.questions = [
            {
                "q": "When something breaks, what do you do first?",
                "options": {
                    "1": ("Understand why", {"depth": 2}),
                    "2": ("Fix immediately", {"action": 2}),
                    "3": ("Wait and observe", {"avoidance": 2}),
                    "4": ("Ask someone", {"emotion": 1})
                }
            },
            {
                "q": "You learn a useful skill. What usually happens?",
                "options": {
                    "1": ("I wait until confident", {"avoidance": 2}),
                    "2": ("I try it quickly", {"action": 2}),
                    "3": ("I study it deeply", {"depth": 2}),
                    "4": ("I move on", {"emotion": 1})
                }
            },
            {
                "q": "Too many options make you feel…",
                "options": {
                    "1": ("Curious", {"depth": 1}),
                    "2": ("Overwhelmed", {"avoidance": 2}),
                    "3": ("Need structure", {"structure": 2}),
                    "4": ("Detached", {"emotion": 1})
                }
            }
        ]

    def run(self, brain: CognitiveModel):
        history = []
        print("\nHPOS initialized.")
        print("This is not a test. Answer honestly.\n")

        for i, q in enumerate(self.questions, start=1):
            print(f"Q{i}. {q['q']}")
            for k, v in q["options"].items():
                print(f"  {k}. {v[0]}")
            choice = input("> ").strip()

            if choice not in q["options"]:
                print("Invalid input. Skipping.\n")
                continue

            answer_text, effect = q["options"][choice]
            brain.apply_effect(effect)
            history.append({
                "question": q["q"],
                "answer": answer_text
            })

            print(AIPersonality.speak("observer"))
            print()

        return history


# -------------------------------
# PROBLEM ASSIGNMENT ENGINE
# -------------------------------

class ProblemEngine:
    @staticmethod
    def assign(brain: CognitiveModel):
        # Simple causal logic (expandable)
        if brain.depth > brain.action and brain.avoidance > 1:
            return {
                "title": "Learning Without Application",
                "description": (
                    "You gain insight easily, but execution waits for certainty. "
                    "This creates a gap between knowing and doing."
                )
            }

        return {
            "title": "Unclear Direction",
            "description": (
                "Your energy is present, but it isn’t yet aligned to one path."
            )
        }


# -------------------------------
# LIFE EXECUTION ENGINE
# -------------------------------

class ExecutionEngine:
    @staticmethod
    def week_plan(problem_title):
        return [
            "Week 1: Observe where this problem appears in daily life. Do not fix it.",
            "Week 2: Change one small behavior related to this problem.",
            "Week 3: Test your change with real people or real conditions.",
            "Week 4: Improve what worked or simplify what didn’t."
        ]


# -------------------------------
# HPOS SYSTEM CONTROLLER
# -------------------------------

class HPOS:
    def __init__(self):
        self.brain = CognitiveModel()
        self.questions = QuestionEngine()
        self.problem = None
        self.history = []
        self.start_time = datetime.datetime.now()

    def run(self):
        self.history = self.questions.run(self.brain)

        print("\n--- MIRROR ---")
        insights = self.brain.mirror_insights()
        for i in insights:
            print("-", i)

        confirm = input("\nDoes this feel accurate? (y/n): ").lower()
        if confirm != "y":
            print("HPOS will adapt next time. Session ending.")
            sys.exit()

        self.problem = ProblemEngine.assign(self.brain)

        print("\n--- CORE PROBLEM ---")
        print(self.problem["title"])
        print(self.problem["description"])

        print("\n--- EXECUTION PLAN ---")
        for step in ExecutionEngine.week_plan(self.problem["title"]):
            print(step)

        self.export_for_chatgpt()

    def export_for_chatgpt(self):
        payload = {
            "system": "HPOS",
            "timestamp": self.start_time.isoformat(),
            "cognitive_map": self.brain.as_dict(),
            "mirror_insights": self.brain.mirror_insights(),
            "problem": self.problem,
            "instruction": (
                "Continue guiding this person step by step. "
                "Do not restart analysis. Stay until the goal is reached."
            )
        }

        print("\n--- CHATGPT HANDOFF DATA ---")
        print(json.dumps(payload, indent=2))


# -------------------------------
# ENTRY POINT
# -------------------------------

if __name__ == "__main__":
    system = HPOS()
    system.run()

